/*
*
* Tag: Union Find
* Time: O(n)
* Space: O(n)
*/

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        if(initial.size() == 0) {
            return 0;
        }
        
        int n = graph.size();
        vector<int> fa(n, -1);
        for(int i = n - 1; i >= 0; -- i) {
            fa[i] -= i;
        }
        
        for(int i = 0; i < n; ++ i) {
            for(int j = i + 1; j < n; ++ j) {
                if(graph[i][j] == 0) {
                    continue;
                }
                unionSet(fa, i, j);
            }
        }
        
        vector<int> setCnt(n, 0);
        for(int i = 0; i < n; ++ i) {
            int u = findFa(fa, i);
            ++ setCnt[u];
        }
        
        vector<int> faCnt(n, 0);
        for(int i = 0; i < initial.size(); ++ i) {
            int u = findFa(fa, initial[i]);
            ++ faCnt[u];
        }
        
        int ans = 0, maxCnt = -1;
        for(int i = 0; i < initial.size(); ++ i) {
            int u = findFa(fa, initial[i]);
            int v = 0;
            if(faCnt[u] == 1) {
                v = setCnt[u];
            }
            if(maxCnt < v) {
                maxCnt = v;
                ans = initial[i];
            } else if(maxCnt == v) {
                ans = min(ans, initial[i]);
            }
        }
        return ans;
    }
    
private:
    inline void unionSet(vector<int> &fa, int u, int v) {
        int faU = findFa(fa, u), faV = findFa(fa, v);
        if(fa[faU] == fa[faV]) {
            return ;
        }
        
        if(fa[faU] <= fa[faV]) {
            fa[faV] = faU;
        } else {
            fa[faU] = faV;
        }
        return ;
    }
    
    int findFa(vector<int> &fa, int u) {
        int s = u;
        for(; fa[s] >= 0; s = fa[s]) ;
        
        while(u != s) {
            int tmp = fa[u];
            fa[u] = s;
            u = tmp;
        }
        return s;
    }
};
